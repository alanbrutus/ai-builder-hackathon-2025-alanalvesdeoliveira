import { NextResponse } from 'next/server';
import { getConnection } from '@/lib/db';
import { sendToGemini } from '@/lib/gemini';
import sql from 'mssql';

/**
 * Parseia a resposta da IA e salva as cota√ß√µes no banco de dados
 */
async function parsearESalvarCotacoes(
  respostaIA: string,
  pecas: any[],
  conversaId: number,
  pool: sql.ConnectionPool
): Promise<number> {
  let totalSalvas = 0;

  try {
    // Parsear resposta da IA para extrair cota√ß√µes
    const linhas = respostaIA.split('\n');
    let cotacaoAtual: any = {};
    let dentroDeSecaoPeca = false;
    let nomePecaAtual = '';

    for (let i = 0; i < linhas.length; i++) {
      const linha = linhas[i].trim();

      // Detectar in√≠cio de se√ß√£o de pe√ßa (ex: "### 1. Bieleta da Barra Estabilizadora")
      if (linha.match(/^###\s+\d+\.\s+(.+)/)) {
        // Salvar cota√ß√£o anterior se existir
        if (cotacaoAtual.nomePeca) {
          await salvarCotacao(cotacaoAtual, pecas, conversaId, pool);
          totalSalvas++;
        }
        
        const match = linha.match(/^###\s+\d+\.\s+(.+)/);
        nomePecaAtual = match ? match[1].trim() : '';
        dentroDeSecaoPeca = true;
        cotacaoAtual = { nomePeca: nomePecaAtual };
        continue;
      }

      if (!dentroDeSecaoPeca) continue;

      // Detectar tipo de cota√ß√£o (suporta m√∫ltiplos formatos)
      const isEcommerce = linha.includes('e-Commerce') || 
                          linha.includes('e-commerce') ||
                          linha.includes('E-Commerce') ||
                          linha.match(/\*\*\s*Tipo:\s*\*\*\s*e-Commerce/i);
      
      const isLojaFisica = linha.includes('Loja F√≠sica') || 
                           linha.includes('loja f√≠sica') ||
                           linha.includes('Loja Fisica') ||
                           linha.match(/\*\*\s*Tipo:\s*\*\*\s*Loja\s+F[i√≠]sica/i);

      if (isEcommerce) {
        if (cotacaoAtual.tipoCotacao) {
          await salvarCotacao(cotacaoAtual, pecas, conversaId, pool);
          totalSalvas++;
        }
        cotacaoAtual = { nomePeca: nomePecaAtual, tipoCotacao: 'E-Commerce' };
      } else if (isLojaFisica) {
        if (cotacaoAtual.tipoCotacao) {
          await salvarCotacao(cotacaoAtual, pecas, conversaId, pool);
          totalSalvas++;
        }
        cotacaoAtual = { nomePeca: nomePecaAtual, tipoCotacao: 'Loja F√≠sica' };
      }

      // Extrair link (e-commerce)
      if (linha.includes('http://') || linha.includes('https://')) {
        const linkMatch = linha.match(/(https?:\/\/[^\s\)]+)/);
        if (linkMatch && !cotacaoAtual.link) {
          cotacaoAtual.link = linkMatch[1];
        }
      }

      // Extrair endere√ßo (loja f√≠sica)
      if (linha.includes('Endere√ßo:') || linha.match(/[A-Z][a-z]+\s+[A-Z][a-z]+.*\d+.*-.*,/)) {
        const enderecoMatch = linha.match(/:\s*(.+)/);
        if (enderecoMatch) {
          cotacaoAtual.endereco = enderecoMatch[1].trim();
        } else if (!cotacaoAtual.endereco && linha.match(/[A-Z][a-z]+.*\d+/)) {
          cotacaoAtual.endereco = linha.replace(/^\*\*/, '').replace(/\*\*$/, '').trim();
        }
      }

      // Extrair nome da loja
      if (linha.includes('**') && linha.includes(':') && cotacaoAtual.tipoCotacao === 'Loja F√≠sica') {
        const lojaMatch = linha.match(/\*\*([^*:]+)\*\*:/);
        if (lojaMatch && !cotacaoAtual.nomeLoja) {
          cotacaoAtual.nomeLoja = lojaMatch[1].trim();
        }
      }

      // Extrair pre√ßo (suporta m√∫ltiplos formatos)
      if (linha.includes('R$') || linha.includes('Pre√ßo:') || linha.match(/üí∞|üíµ/)) {
        // Faixa de pre√ßo: R$ 150,00 - R$ 200,00 ou R$ 150 - R$ 200
        const faixaMatch = linha.match(/R\$\s*([\d.,]+)\s*-\s*R\$\s*([\d.,]+)/);
        if (faixaMatch && !cotacaoAtual.precoMinimo) {
          const min = faixaMatch[1].replace(/\./g, '').replace(',', '.');
          const max = faixaMatch[2].replace(/\./g, '').replace(',', '.');
          cotacaoAtual.precoMinimo = parseFloat(min);
          cotacaoAtual.precoMaximo = parseFloat(max);
        } else {
          // Pre√ßo √∫nico: R$ 189,90
          const unicoMatch = linha.match(/R\$\s*([\d.,]+)(?!\s*-)/);
          if (unicoMatch && !cotacaoAtual.preco && !cotacaoAtual.precoMinimo) {
            const preco = unicoMatch[1].replace(/\./g, '').replace(',', '.');
            cotacaoAtual.preco = parseFloat(preco);
          }
        }
      }

      // Extrair condi√ß√µes de pagamento (m√∫ltiplos formatos)
      if (linha.match(/Condi√ß√µes de Pagamento:|Pagamento:|üí≥/i)) {
        const pagamentoMatch = linha.match(/(?:Condi√ß√µes de )?Pagamento:\s*\*?\*?\s*(.+)/i);
        if (pagamentoMatch && !cotacaoAtual.condicoesPagamento) {
          cotacaoAtual.condicoesPagamento = pagamentoMatch[1].replace(/\*\*/g, '').replace(/\*/g, '').trim();
        }
      }

      // Extrair disponibilidade (m√∫ltiplos formatos)
      if (linha.match(/Disponibilidade:|üì¶|‚úÖ/i)) {
        const dispMatch = linha.match(/Disponibilidade:\s*\*?\*?\s*(.+)/i);
        if (dispMatch && !cotacaoAtual.disponibilidade) {
          cotacaoAtual.disponibilidade = dispMatch[1].replace(/\*\*/g, '').replace(/\*/g, '').trim();
        }
      }

      // Extrair prazo de entrega (m√∫ltiplos formatos)
      if (linha.match(/Prazos? de Entrega:|üöö|üìÖ/i)) {
        const prazoMatch = linha.match(/Prazos? de Entrega:\s*\*?\*?\s*(.+)/i);
        if (prazoMatch && !cotacaoAtual.prazoEntrega) {
          cotacaoAtual.prazoEntrega = prazoMatch[1].replace(/\*\*/g, '').replace(/\*/g, '').trim();
        }
      }
      
      // Extrair observa√ß√µes gerais (se√ß√£o de observa√ß√µes)
      if (linha.match(/^\s*\*\s+\*\*Observa√ß√µes/i) || linha.match(/^üìù\s*\*\*Observa√ß√µes/i)) {
        // Marcar que entramos na se√ß√£o de observa√ß√µes
        cotacaoAtual.dentroObservacoes = true;
      } else if (cotacaoAtual.dentroObservacoes && linha.match(/^\s*\*/)) {
        // Capturar linhas de observa√ß√£o
        const obsTexto = linha.replace(/^\s*\*\s*\*?\*?/, '').replace(/\*\*/g, '').trim();
        if (obsTexto && obsTexto.length > 5) {
          if (!cotacaoAtual.observacoes) {
            cotacaoAtual.observacoes = obsTexto;
          } else {
            cotacaoAtual.observacoes += '; ' + obsTexto;
          }
        }
      }
    }

    // Salvar √∫ltima cota√ß√£o
    if (cotacaoAtual.nomePeca && cotacaoAtual.tipoCotacao) {
      await salvarCotacao(cotacaoAtual, pecas, conversaId, pool);
      totalSalvas++;
    }

  } catch (error) {
    console.error('‚ùå Erro ao parsear cota√ß√µes:', error);
  }

  return totalSalvas;
}

/**
 * Salva uma cota√ß√£o individual no banco de dados
 */
async function salvarCotacao(
  cotacao: any,
  pecas: any[],
  conversaId: number,
  pool: sql.ConnectionPool
): Promise<void> {
  try {
    // Encontrar pe√ßa correspondente
    const peca = pecas.find(p => 
      p.NomePeca.toLowerCase().includes(cotacao.nomePeca.toLowerCase()) ||
      cotacao.nomePeca.toLowerCase().includes(p.NomePeca.toLowerCase())
    );

    if (!peca) {
      console.warn(`‚ö†Ô∏è  Pe√ßa n√£o encontrada para cota√ß√£o: ${cotacao.nomePeca}`);
      return;
    }

    // Validar tipo de cota√ß√£o
    if (!cotacao.tipoCotacao || !['E-Commerce', 'Loja F√≠sica'].includes(cotacao.tipoCotacao)) {
      console.warn(`‚ö†Ô∏è  Tipo de cota√ß√£o inv√°lido: ${cotacao.tipoCotacao}`);
      return;
    }

    // Registrar cota√ß√£o
    await pool
      .request()
      .input('ConversaId', conversaId)
      .input('ProblemaId', peca.ProblemaId || null)
      .input('PecaIdentificadaId', peca.Id)
      .input('NomePeca', cotacao.nomePeca)
      .input('TipoCotacao', cotacao.tipoCotacao)
      .input('Link', cotacao.link || null)
      .input('Endereco', cotacao.endereco || null)
      .input('NomeLoja', cotacao.nomeLoja || null)
      .input('Telefone', cotacao.telefone || null)
      .input('Preco', cotacao.preco || null)
      .input('PrecoMinimo', cotacao.precoMinimo || null)
      .input('PrecoMaximo', cotacao.precoMaximo || null)
      .input('CondicoesPagamento', cotacao.condicoesPagamento || null)
      .input('Observacoes', cotacao.observacoes || null)
      .input('Disponibilidade', cotacao.disponibilidade || null)
      .input('PrazoEntrega', cotacao.prazoEntrega || null)
      .input('EstadoPeca', cotacao.estadoPeca || null)
      .execute('AIHT_sp_RegistrarCotacao');

    console.log(`  ‚úÖ Cota√ß√£o salva: ${cotacao.nomePeca} (${cotacao.tipoCotacao})`);
  } catch (error) {
    console.error(`  ‚ùå Erro ao salvar cota√ß√£o ${cotacao.nomePeca}:`, error);
  }
}

export async function POST(request: Request) {
  try {
    const { conversaId, mensagemCliente } = await request.json();

    if (!conversaId) {
      return NextResponse.json({
        success: false,
        error: 'ID da conversa √© obrigat√≥rio'
      }, { status: 400 });
    }

    const pool = await getConnection();

    // 1. Verificar se a mensagem tem inten√ß√£o de cota√ß√£o
    const intencaoResult = await pool
      .request()
      .input('Mensagem', mensagemCliente)
      .execute('AIHT_sp_VerificarIntencaoCotacao');

    const intencaoCotacao = intencaoResult.recordset[0]?.IntencaoCotacao;
    const palavrasEncontradas = intencaoResult.recordset[0]?.PalavrasEncontradas;

    console.log('üîç Verificando inten√ß√£o de cota√ß√£o...');
    console.log('   Inten√ß√£o detectada:', intencaoCotacao ? 'SIM' : 'N√ÉO');
    console.log('   Palavras encontradas:', palavrasEncontradas || 'nenhuma');

    if (!intencaoCotacao) {
      return NextResponse.json({
        success: true,
        intencaoCotacao: false,
        mensagem: 'Mensagem n√£o indica inten√ß√£o de cota√ß√£o'
      });
    }

    // 2. Buscar pe√ßas identificadas na conversa
    const pecasResult = await pool
      .request()
      .input('ConversaId', conversaId)
      .execute('AIHT_sp_ListarPecasParaCotacao');

    const pecas = pecasResult.recordset;

    if (pecas.length === 0) {
      return NextResponse.json({
        success: true,
        intencaoCotacao: true,
        mensagem: 'Nenhuma pe√ßa foi identificada ainda nesta conversa.'
      });
    }

    console.log(`üì¶ ${pecas.length} pe√ßas encontradas para cota√ß√£o`);

    // 3. Buscar prompt de cota√ß√£o do banco de dados
    const promptResult = await pool
      .request()
      .input('Contexto', 'cotacao')
      .execute('AIHT_sp_ObterPromptPorContexto');

    let promptTemplate = promptResult.recordset[0]?.ConteudoPrompt;

    if (!promptTemplate) {
      console.warn('‚ö†Ô∏è  Prompt de cota√ß√£o n√£o encontrado, usando padr√£o');
      promptTemplate = `Preciso que realize um processo de cota√ß√£o para o {{fabricante_veiculo}} {{modelo_veiculo}} em e-Commerce e lojas presenciais para as pe√ßas relacionadas abaixo:

-- In√≠cio Pe√ßas
{{lista_pecas}}
-- Fim Pe√ßas

Para cada pe√ßa, forne√ßa: nome, tipo (e-Commerce/Loja F√≠sica), link/endere√ßo, pre√ßo estimado e condi√ß√µes de pagamento.`;
    }

    // 4. Substituir vari√°veis no prompt
    const fabricanteVeiculo = pecas[0]?.MarcaVeiculo || 'Ve√≠culo';
    const modeloVeiculo = pecas[0]?.ModeloVeiculo || '';
    
    // Formatar lista de pe√ßas
    const listaPecas = pecas.map((p, i) => 
      `${i + 1}. ${p.NomePeca} - ${p.CodigoPeca || 'Sem c√≥digo'}`
    ).join('\n');

    // Substituir vari√°veis
    const promptCotacao = promptTemplate
      .replace(/\{\{fabricante_veiculo\}\}/g, fabricanteVeiculo)
      .replace(/\{\{modelo_veiculo\}\}/g, modeloVeiculo)
      .replace(/\{\{lista_pecas\}\}/g, listaPecas);

    console.log('üìù Prompt montado com vari√°veis substitu√≠das');

    // 4. Enviar para Gemini
    console.log('ü§ñ Enviando para Gemini...');
    const inicioTempo = Date.now();
    const resultadoIA = await sendToGemini(promptCotacao, mensagemCliente);
    const tempoResposta = Date.now() - inicioTempo;

    if (!resultadoIA.success) {
      console.error('‚ùå Erro na resposta da IA:', resultadoIA.error);
      return NextResponse.json({
        success: false,
        error: resultadoIA.error
      }, { status: 500 });
    }

    console.log('‚úÖ Cota√ß√£o gerada com sucesso');

    // 5. Registrar log da chamada
    await pool
      .request()
      .input('ConversaId', conversaId)
      .input('TipoChamada', 'cotacao')
      .input('MensagemCliente', mensagemCliente || 'Mensagem n√£o informada')
      .input('PromptEnviado', promptCotacao || 'Prompt n√£o dispon√≠vel')
      .input('RespostaRecebida', resultadoIA.response || '')
      .input('TempoResposta', tempoResposta)
      .input('Sucesso', resultadoIA.success ? 1 : 0)
      .input('MensagemErro', resultadoIA.error || null)
      .input('ModeloIA', 'gemini-pro')
      .execute('AIHT_sp_RegistrarChamadaIA');

    // 6. Parsear e salvar cota√ß√µes no banco de dados
    console.log('üíæ Parseando e salvando cota√ß√µes no banco...');
    const cotacoesSalvas = await parsearESalvarCotacoes(
      resultadoIA.response || '',
      pecas,
      conversaId,
      pool
    );
    console.log(`‚úÖ ${cotacoesSalvas} cota√ß√µes salvas no banco de dados`);

    return NextResponse.json({
      success: true,
      intencaoCotacao: true,
      cotacao: resultadoIA.response,
      pecas: pecas,
      palavrasEncontradas: palavrasEncontradas,
      cotacoesSalvas: cotacoesSalvas
    });

  } catch (error: any) {
    console.error('‚ùå Erro ao gerar cota√ß√£o:', error);
    return NextResponse.json({
      success: false,
      error: error.message
    }, { status: 500 });
  }
}
